<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Assert_DimensionMismatchFormat" xml:space="preserve">
    <value>esperado tiene {0} dimensiones; real tiene {1} dimensiones. {2}</value>
  </data>
  <data name="Assert_EasterEggAssertClassPassed" xml:space="preserve">
    <value>OK, afirmó Rubberduck. ¿Ahora que?</value>
  </data>
  <data name="Assert_EasterEggIFakePassed" xml:space="preserve">
    <value>Esperado: desbordamiento de pila ?; Actual: cláusula de guardia.</value>
  </data>
  <data name="Assert_EasterEggIVerifyPassed" xml:space="preserve">
    <value>IVerify también.</value>
  </data>
  <data name="Assert_FailedMessageFormat" xml:space="preserve">
    <value>La afirmación {0} ha fallado. {1}</value>
  </data>
  <data name="Assert_InvalidFakePassThrough" xml:space="preserve">
    <value>Configuración inválida de IFake {0}. La propiedad PassThrough debe ser False.</value>
  </data>
  <data name="Assert_LBoundMismatchFormat" xml:space="preserve">
    <value>Dimensión {0}: se espera que tenga un LBound de {1}; actualmente tiene un LBound de {2}. {3}</value>
  </data>
  <data name="Assert_MismatchedTypes" xml:space="preserve">
    <value>Los valores [esperado] y [real] no son del mismo tipo.</value>
  </data>
  <data name="Assert_NeitherParameterIsArray" xml:space="preserve">
    <value>Ni [esperado] ni [real] son arreglos.</value>
  </data>
  <data name="Assert_NotImplemented" xml:space="preserve">
    <value>No se ha implementado.</value>
  </data>
  <data name="Assert_ParameterIsNotArrayFormat" xml:space="preserve">
    <value>{0} no es un arreglo.</value>
  </data>
  <data name="Assert_ParameterResultFormat" xml:space="preserve">
    <value>Esperado: {0}; Actual: {1}. {2}</value>
  </data>
  <data name="Assert_ReferenceValueMismatch" xml:space="preserve">
    <value>[esperado] es un tipo de referencia y [real] es un tipo de valor.</value>
  </data>
  <data name="Assert_UBoundMismatchFormat" xml:space="preserve">
    <value>Dimensión {0}: se espera que tenga un UBound de {1}; real tiene un límite de {2}. {3}</value>
  </data>
  <data name="Assert_UnexpectedArrayFormat" xml:space="preserve">
    <value>[esperado] y [actual] son arreglos. Considera utilizar {0}.</value>
  </data>
  <data name="Assert_UnexpectedNullArraysFormat" xml:space="preserve">
    <value>[esperado] y [actual] son Nada. Considera utilizar {0}.</value>
  </data>
  <data name="Assert_UnexpectedReferenceComparisonFormat" xml:space="preserve">
    <value>[esperado] y [actual] son tipos de referencia. Considera utilizar {0}.</value>
  </data>
  <data name="Assert_UnexpectedValueComparisonFormat" xml:space="preserve">
    <value>[esperado] y [real] son tipos de valor. Considera utilizar {0}.</value>
  </data>
  <data name="Assert_ValueReferenceMismatch" xml:space="preserve">
    <value>[esperado] es un tipo de valor y [real] es un tipo de referencia.</value>
  </data>
  <data name="Assert_VerifyInternalErrorMessage" xml:space="preserve">
    <value>Rubberduck no pudo procesar los resultados de invocación.</value>
  </data>
  <data name="Assert_VerifyNoInvocationFormat" xml:space="preserve">
    <value>No hay invocación coincidente para el parámetro {0}; Sólo {1} invocaciones. {2}</value>
  </data>
  <data name="Assert_VerifyParameterNonNumeric" xml:space="preserve">
    <value>El parámetro {0} no era un valor numérico en la invocación {1}. {2}</value>
  </data>
  <data name="Assert_VerifyParameterNotPassed" xml:space="preserve">
    <value>El parámetro {0} no se pasó en la invocación {1}. {2}</value>
  </data>
  <data name="Prerequisite_EarlyBindingReferenceMissing" xml:space="preserve">
    <value>La referencia a Rubberduck requerida para las pruebas de unión temprana no se pudo resolver. Puede estar corrupta.</value>
  </data>
  <data name="TestRunner_ComException" xml:space="preserve">
    <value>Excepción de COM inesperada al ejecutar pruebas.</value>
  </data>
  <data name="TestRunner_ExceptionDuringRun" xml:space="preserve">
    <value>La ejecución de un método de prueba falló con una excepción.</value>
  </data>
  <data name="TestRunner_GenericException" xml:space="preserve">
    <value>Excepción inesperada al ejecutar pruebas.</value>
  </data>
  <data name="TestRunner_ModuleInitializeFailure" xml:space="preserve">
    <value>Algo salió mal al intentar ejecutar @ModuleInitialize. Se saltó el módulo.</value>
  </data>
  <data name="TestRunner_TestInitializeFailure" xml:space="preserve">
    <value>Algo salió mal al intentar ejecutar @TestInitialize. Prueba saltada.</value>
  </data>
</root>